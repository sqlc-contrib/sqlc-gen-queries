-- sqlfluff:dialect:{{.Engine}}
-- sqlfluff:max_line_length:1024
-- sqlfluff:rules:capitalisation.keywords:capitalisation_policy:upper

SET search_path TO {{.Schema}};

{{range $idx, $key := .Table.GetUniqueKeys}}-- Get{{table_name $.Table.Name "one"}}{{query_index $key}} retrieves a single row from '{{$.Table.Name}}' by {{$key.Name}}.
-- Returns the row or an error if not found.
-- name: Get{{table_name $.Table.Name "one"}}{{query_index $key}} :one
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
WHERE
    {{query_condition $.Table $key}};
{{- if eq $key $.Table.PrimaryKey}}
{{- range $fk := $.Table.ForeignKeys}}

-- Get{{table_name $.Table.Name "one"}}{{query_index $key}}With{{table_name (table_ref $fk) "one"}} retrieves a row from '{{$.Table.Name}}' by its primary key with its related '{{$fk.References.Table}}' record.
-- The result is a struct with both tables table_embedded.
-- name: Get{{table_name $.Table.Name "one"}}{{query_index $key}}With{{table_name (table_ref $fk) "one"}} :one
SELECT
    {{table_embed $.Table.Name}}, {{table_embed $fk.References.Table}}
FROM
    {{$.Table.Name}}
{{table_join $.Table $fk}}
WHERE
    {{query_condition $.Table $key}};
{{- end}}
{{- end}}

-- BatchGet{{table_name $.Table.Name "many"}}{{query_index $key}} retrieves multiple rows from '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Executes the query once for each provided key value and returns individual results.
-- name: BatchGet{{table_name $.Table.Name "many"}}{{query_index $key}} :batchone
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
WHERE
    {{query_condition $.Table $key}};
{{- if eq $key $.Table.PrimaryKey}}
{{- range $fk := $.Table.ForeignKeys}}

-- BatchGet{{table_name $.Table.Name "many"}}{{query_index $key}}With{{table_name (table_ref $fk) "one"}} retrieves rows from '{{$.Table.Name}}' by primary key with their related '{{$fk.References.Table}}' records.
-- The result is a struct with both tables table_embedded for each row.
-- name: BatchGet{{table_name $.Table.Name "many"}}{{query_index $key}}With{{table_name (table_ref $fk) "one"}} :batchone
SELECT
    {{table_embed $.Table.Name}}, {{table_embed $fk.References.Table}}
FROM
    {{$.Table.Name}}
{{table_join $.Table $fk}}
WHERE
    {{query_condition $.Table $key}};
{{- end}}
{{- end}}

-- Update{{table_name $.Table.Name "one"}}{{query_index $key}} updates a row in '{{$.Table.Name}}' identified by {{$key.Name}}.
-- Uses update_mask to specify which fields to update. Returns the updated row.
-- name: Update{{table_name $.Table.Name "one"}}{{query_index $key}} :one
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.GetNonPrimaryKeyColumns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{query_condition $.Table $key}}
RETURNING *;

-- ExecUpdate{{table_name $.Table.Name "one"}}{{query_index $key}} updates a row in '{{$.Table.Name}}' identified by {{$key.Name}}.
-- Uses update_mask to specify which fields to update. Returns number of affected rows.
-- name: ExecUpdate{{table_name $.Table.Name "one"}}{{query_index $key}} :exec
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.GetNonPrimaryKeyColumns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{query_condition $.Table $key}};

-- BatchUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} updates multiple rows in '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns updated rows.
-- name: BatchUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} :batchone
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.GetNonPrimaryKeyColumns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{query_condition $.Table $key}}
RETURNING *;

-- BatchExecUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} updates multiple rows in '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns number of affected rows.
-- name: BatchExecUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} :batchexec
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.GetNonPrimaryKeyColumns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{query_condition $.Table $key}};

-- Delete{{table_name $.Table.Name "one"}}{{query_index $key}} deletes a single row from '{{$.Table.Name}}' by {{$key.Name}}.
-- Returns the deleted row or an error if not found.
-- name: Delete{{table_name $.Table.Name "one"}}{{query_index $key}} :one
DELETE FROM {{$.Table.Name}}
WHERE
    {{query_condition $.Table $key}}
RETURNING *;

-- ExecDelete{{table_name $.Table.Name "one"}}{{query_index $key}} deletes a single row from '{{$.Table.Name}}' by {{$key.Name}}.
-- Returns number of affected rows (0 if not found, 1 if deleted).
-- name: ExecDelete{{table_name $.Table.Name "one"}}{{query_index $key}} :exec
DELETE FROM {{$.Table.Name}}
WHERE
    {{query_condition $.Table $key}};

-- BatchDelete{{table_name $.Table.Name "many"}}{{query_index $key}} deletes multiple rows from '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Executes the delete once for each provided key value and returns deleted rows.
-- name: BatchDelete{{table_name $.Table.Name "many"}}{{query_index $key}} :batchone
DELETE FROM {{$.Table.Name}}
WHERE
    {{query_condition $.Table $key}}
RETURNING *;

-- BatchExecDelete{{table_name $.Table.Name "many"}}{{query_index $key}} deletes multiple rows from '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Executes the delete once for each provided key value and returns number of affected rows.
-- name: BatchExecDelete{{table_name $.Table.Name "many"}}{{query_index $key}} :batchexec
DELETE FROM {{$.Table.Name}}
WHERE
    {{query_condition $.Table $key}};

{{end}}
-- Insert{{table_name .Table.Name "one"}} inserts a new row into '{{.Table.Name}}'.
-- Returns the inserted row with all fields populated.
-- name: Insert{{table_name .Table.Name "one"}} :one
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{query_argument $column}}
{{- end}}
)
RETURNING *;

-- ExecInsert{{table_name .Table.Name "one"}} inserts a new row into '{{.Table.Name}}'.
-- Returns number of affected rows (should always be 1 on success).
-- name: ExecInsert{{table_name .Table.Name "one"}} :exec
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{query_argument $column}}
{{- end}}
);

-- BatchInsert{{table_name .Table.Name "many"}} inserts multiple rows into '{{.Table.Name}}' in a single batch operation.
-- Executes the insert once for each provided set of values and returns inserted rows.
-- name: BatchInsert{{table_name .Table.Name "many"}} :batchone
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{query_argument $column}}
{{- end}}
)
RETURNING *;

-- BatchExecInsert{{table_name .Table.Name "many"}} inserts multiple rows into '{{.Table.Name}}' in a single batch operation.
-- Executes the insert once for each provided set of values and returns number of affected rows.
-- name: BatchExecInsert{{table_name .Table.Name "many"}} :batchexec
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{query_argument $column}}
{{- end}}
);

-- Copy{{table_name .Table.Name "many"}} efficiently bulk inserts multiple rows into '{{.Table.Name}}' using PostgreSQL COPY protocol.
-- This is the fastest way to insert large amounts of data. Does not return inserted rows.
-- name: Copy{{table_name .Table.Name "many"}} :copyfrom
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{query_argument $column}}
{{- end}}
);

-- List{{table_name .Table.Name "many"}} retrieves a paginated list of rows from '{{$.Table.Name}}'.
-- 
-- Filtering:
--   The 'filter' parameter enables dynamic WHERE clauses for flexible querying.
--   Pass NULL for no filtering, or use a query builder (e.g., pgxmql.WhereClause) 
--   to construct runtime conditions. The void type cast allows query rewriting.
--   Example: filter can add conditions like "status = 'active' AND created_at > '2024-01-01'"
--
-- Pagination:
--   Cursor-based: Use page_start (ID of last item from previous page) + page_limit.
--                 Returns items AFTER the cursor. Set page_start to the last item's ID from current page as next cursor.
--   Offset-based: Use page_offset + page_limit for traditional page number pagination.
-- name: List{{table_name .Table.Name "many"}} :many
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
{{- $page_start := page_start $.Table}}
{{- $page_order := page_order $.Table}}
WHERE
    sqlc.narg(filter)::void IS NULL
    {{- if $page_start}}
    AND {{$page_start}}
    {{- end}}
{{- if $page_order}}
ORDER BY
    {{$page_order}}
{{- end}}
LIMIT
    sqlc.narg(page_limit)::int
OFFSET
    sqlc.narg(page_offset)::int;

{{range $idx, $key := .Table.GetNonUniqueIndexes}}-- List{{table_name $.Table.Name "many"}}{{query_index $key}} retrieves a paginated list of rows from '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- 
-- Filtering:
--   The 'filter' parameter enables dynamic WHERE clauses for flexible querying.
--   Pass NULL for no filtering, or use a query builder (e.g., pgxmql.WhereClause) 
--   to construct runtime conditions. The void type cast allows query rewriting.
--   Example: filter can add conditions like "status = 'active' AND created_at > '2024-01-01'"
--
-- Pagination:
--   Cursor-based: Use page_start (ID of last item from previous page) + page_limit.
--                 Returns items AFTER the cursor. Set page_start to the last item's ID from current page as next cursor.
--   Offset-based: Use page_offset + page_limit for traditional page number pagination.
-- name: List{{table_name $.Table.Name "many"}}{{query_index $key}} :many
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
{{- $condition := query_condition $.Table $key}}
{{- $page_start := page_start $.Table}}
{{- $page_order := page_order $.Table}}
{{- if $condition}}
WHERE
    {{$condition}}
    {{- if $page_start}}
    AND {{$page_start}}
    {{- end}}
{{- else if $page_start}}
WHERE
    {{$page_start}}
{{- end}}
{{- if $page_order}}
ORDER BY
    {{$page_order}}
{{- end}}
LIMIT
    sqlc.narg(page_limit)::int
OFFSET
    sqlc.narg(page_offset)::int;

-- Update{{table_name $.Table.Name "many"}}{{query_index $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Uses update_mask to specify which fields to update. Returns updated rows.
-- name: Update{{table_name $.Table.Name "many"}}{{query_index $key}} :many
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}}
RETURNING *;

-- ExecUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Uses update_mask to specify which fields to update. Returns number of affected rows.
-- name: ExecUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} :execrows
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}};

-- BatchUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns updated rows.
-- name: BatchUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} :batchmany
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}}
RETURNING *;

-- BatchExecUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns number of affected rows.
-- name: BatchExecUpdate{{table_name $.Table.Name "many"}}{{query_index $key}} :batchexec
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{query_argument $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}};

-- Delete{{table_name $.Table.Name "many"}}{{query_index $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Returns the deleted rows.
-- name: Delete{{table_name $.Table.Name "many"}}{{query_index $key}} :many
DELETE FROM {{$.Table.Name}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}}
RETURNING *;

-- ExecDelete{{table_name $.Table.Name "many"}}{{query_index $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Returns number of affected rows.
-- name: ExecDelete{{table_name $.Table.Name "many"}}{{query_index $key}} :execrows
DELETE FROM {{$.Table.Name}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}};

-- BatchDelete{{table_name $.Table.Name "many"}}{{query_index $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Executes the delete once for each provided key value and returns deleted rows.
-- name: BatchDelete{{table_name $.Table.Name "many"}}{{query_index $key}} :batchmany
DELETE FROM {{$.Table.Name}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}}
RETURNING *;

-- BatchExecDelete{{table_name $.Table.Name "many"}}{{query_index $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Executes the delete once for each provided key value and returns number of affected rows.
-- name: BatchExecDelete{{table_name $.Table.Name "many"}}{{query_index $key}} :batchexec
DELETE FROM {{$.Table.Name}}
{{- $condition := query_condition $.Table $key}}
{{- if $condition}}
WHERE
    {{$condition}}
{{- end}};

{{end}}
