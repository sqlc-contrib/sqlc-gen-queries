-- sqlfluff:dialect:{{.Engine}}
-- sqlfluff:max_line_length:1024
-- sqlfluff:rules:capitalisation.keywords:capitalisation_policy:upper

SET search_path TO {{.Schema}};

{{range $idx, $key := .Table.GetUniqueKeys}}-- Get{{by_one $.Table}}{{by_index $.Table $key}} retrieves a single row from '{{$.Table.Name}}' by {{$key.Name}}.
-- Returns the row or an error if not found.
-- name: Get{{by_one $.Table}}{{by_index $.Table $key}} :one
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
WHERE
    {{where $.Table $key}};

-- BatchGet{{by_many $.Table}}{{by_index $.Table $key}} retrieves multiple rows from '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Executes the query once for each provided key value and returns individual results.
-- name: BatchGet{{by_many $.Table}}{{by_index $.Table $key}} :batchone
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
WHERE
    {{where $.Table $key}};

-- Update{{by_one $.Table}}{{by_index $.Table $key}} updates a row in '{{$.Table.Name}}' identified by {{$key.Name}}.
-- Uses update_mask to specify which fields to update. Returns the updated row.
-- name: Update{{by_one $.Table}}{{by_index $.Table $key}} :one
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{where $.Table $key}}
RETURNING *;

-- ExecUpdate{{by_one $.Table}}{{by_index $.Table $key}} updates a row in '{{$.Table.Name}}' identified by {{$key.Name}}.
-- Uses update_mask to specify which fields to update. Returns number of affected rows.
-- name: ExecUpdate{{by_one $.Table}}{{by_index $.Table $key}} :exec
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{where $.Table $key}};

-- BatchUpdate{{by_many $.Table}}{{by_index $.Table $key}} updates multiple rows in '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns updated rows.
-- name: BatchUpdate{{by_many $.Table}}{{by_index $.Table $key}} :batchone
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{where $.Table $key}}
RETURNING *;

-- BatchExecUpdate{{by_many $.Table}}{{by_index $.Table $key}} updates multiple rows in '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns number of affected rows.
-- name: BatchExecUpdate{{by_many $.Table}}{{by_index $.Table $key}} :batchexec
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
WHERE
    {{where $.Table $key}};

-- Delete{{by_one $.Table}}{{by_index $.Table $key}} deletes a single row from '{{$.Table.Name}}' by {{$key.Name}}.
-- Returns the deleted row or an error if not found.
-- name: Delete{{by_one $.Table}}{{by_index $.Table $key}} :one
DELETE FROM {{$.Table.Name}}
WHERE
    {{where $.Table $key}}
RETURNING *;

-- ExecDelete{{by_one $.Table}}{{by_index $.Table $key}} deletes a single row from '{{$.Table.Name}}' by {{$key.Name}}.
-- Returns number of affected rows (0 if not found, 1 if deleted).
-- name: ExecDelete{{by_one $.Table}}{{by_index $.Table $key}} :exec
DELETE FROM {{$.Table.Name}}
WHERE
    {{where $.Table $key}};

-- BatchDelete{{by_many $.Table}}{{by_index $.Table $key}} deletes multiple rows from '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Executes the delete once for each provided key value and returns deleted rows.
-- name: BatchDelete{{by_many $.Table}}{{by_index $.Table $key}} :batchone
DELETE FROM {{$.Table.Name}}
WHERE
    {{where $.Table $key}}
RETURNING *;

-- BatchExecDelete{{by_many $.Table}}{{by_index $.Table $key}} deletes multiple rows from '{{$.Table.Name}}' by {{$key.Name}} in a single batch operation.
-- Executes the delete once for each provided key value and returns number of affected rows.
-- name: BatchExecDelete{{by_many $.Table}}{{by_index $.Table $key}} :batchexec
DELETE FROM {{$.Table.Name}}
WHERE
    {{where $.Table $key}};

{{end}}
-- Insert{{by_one .Table}} inserts a new row into '{{.Table.Name}}'.
-- Returns the inserted row with all fields populated.
-- name: Insert{{by_one .Table}} :one
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{arg $column}}
{{- end}}
)
RETURNING *;

-- ExecInsert{{by_one .Table}} inserts a new row into '{{.Table.Name}}'.
-- Returns number of affected rows (should always be 1 on success).
-- name: ExecInsert{{by_one .Table}} :exec
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{arg $column}}
{{- end}}
);

-- BatchInsert{{by_many .Table}} inserts multiple rows into '{{.Table.Name}}' in a single batch operation.
-- Executes the insert once for each provided set of values and returns inserted rows.
-- name: BatchInsert{{by_many .Table}} :batchone
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{arg $column}}
{{- end}}
)
RETURNING *;

-- BatchExecInsert{{by_many .Table}} inserts multiple rows into '{{.Table.Name}}' in a single batch operation.
-- Executes the insert once for each provided set of values and returns number of affected rows.
-- name: BatchExecInsert{{by_many .Table}} :batchexec
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{arg $column}}
{{- end}}
);

-- Copy{{by_many .Table}} efficiently bulk inserts multiple rows into '{{.Table.Name}}' using PostgreSQL COPY protocol.
-- This is the fastest way to insert large amounts of data. Does not return inserted rows.
-- name: Copy{{by_many .Table}} :copyfrom
INSERT INTO {{.Table.Name}} (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
) VALUES (
{{ range $i, $column := .Table.Columns}}{{if $i}},
{{end}}    {{arg $column}}
{{- end}}
);

-- List{{by_many $.Table}} retrieves a paginated list of rows from '{{$.Table.Name}}'.
-- 
-- Filtering:
--   The 'filter' parameter enables dynamic WHERE clauses for flexible querying.
--   Pass NULL for no filtering, or use a query builder (e.g., pgxmql.WhereClause) 
--   to construct runtime conditions. The void type cast allows query rewriting.
--   Example: filter can add conditions like "status = 'active' AND created_at > '2024-01-01'"
--
-- Pagination:
--   Cursor-based: Use page_start (ID of last item from previous page) + page_limit.
--                 Returns items AFTER the cursor. Set page_start to the last item's ID from current page as next cursor.
--   Offset-based: Use page_offset + page_limit for traditional page number pagination.
-- name: List{{by_many $.Table}} :many
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
WHERE
    COALESCE(sqlc.narg(filter)::void, TRUE)
    AND {{cursor $.Table}}
ORDER BY
    {{order $.Table}}
LIMIT
    sqlc.narg(page_limit)::int
OFFSET
    sqlc.narg(page_offset)::int;

{{range $idx, $key := .Table.GetNonUniqueIndexes}}-- List{{by_many $.Table}}{{by_index $.Table $key}} retrieves a paginated list of rows from '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- 
-- Filtering:
--   The 'filter' parameter enables dynamic WHERE clauses for flexible querying.
--   Pass NULL for no filtering, or use a query builder (e.g., pgxmql.WhereClause) 
--   to construct runtime conditions. The void type cast allows query rewriting.
--   Example: filter can add conditions like "status = 'active' AND created_at > '2024-01-01'"
--
-- Pagination:
--   Cursor-based: Use page_start (ID of last item from previous page) + page_limit.
--                 Returns items AFTER the cursor. Set page_start to the last item's ID from current page as next cursor.
--   Offset-based: Use page_offset + page_limit for traditional page number pagination.
-- name: List{{by_many $.Table}}{{by_index $.Table $key}} :many
SELECT
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}}
{{- end}}
FROM
    {{$.Table.Name}}
{{- $where := where $.Table $key}}
{{- $cursor := cursor $.Table}}
{{- if $where}}
WHERE
    {{$where}}
    {{- if $cursor}}
    AND {{$cursor}}
    {{- end}}
{{- else if $cursor}}
WHERE
    {{$cursor}}
{{- end}}
ORDER BY
    {{order $.Table}}
LIMIT
    sqlc.narg(page_limit)::int
OFFSET
    sqlc.narg(page_offset)::int;

-- Update{{by_many $.Table}}{{by_index $.Table $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Uses update_mask to specify which fields to update. Returns updated rows.
-- name: Update{{by_many $.Table}}{{by_index $.Table $key}} :many
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}}
RETURNING *;

-- ExecUpdate{{by_many $.Table}}{{by_index $.Table $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Uses update_mask to specify which fields to update. Returns number of affected rows.
-- name: ExecUpdate{{by_many $.Table}}{{by_index $.Table $key}} :execrows
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}};

-- BatchUpdate{{by_many $.Table}}{{by_index $.Table $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns updated rows.
-- name: BatchUpdate{{by_many $.Table}}{{by_index $.Table $key}} :batchmany
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}}
RETURNING *;

-- BatchExecUpdate{{by_many $.Table}}{{by_index $.Table $key}} updates multiple rows in '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Uses update_mask for each row to specify which fields to update. Returns number of affected rows.
-- name: BatchExecUpdate{{by_many $.Table}}{{by_index $.Table $key}} :batchexec
UPDATE {{$.Table.Name}}
SET
{{ range $i, $column := $.Table.Columns}}{{if $i}},
{{end}}    {{$column.Name}} = CASE
        WHEN '{{$column.Name}}' = any(sqlc.arg(update_mask))
            THEN {{arg $column}}
        ELSE {{$column.Name}}
    END
{{- end}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}};

-- Delete{{by_many $.Table}}{{by_index $.Table $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Returns the deleted rows.
-- name: Delete{{by_many $.Table}}{{by_index $.Table $key}} :many
DELETE FROM {{$.Table.Name}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}}
RETURNING *;

-- ExecDelete{{by_many $.Table}}{{by_index $.Table $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} filtered by {{$key.Name}}{{end}}.
-- Returns number of affected rows.
-- name: ExecDelete{{by_many $.Table}}{{by_index $.Table $key}} :execrows
DELETE FROM {{$.Table.Name}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}};

-- BatchDelete{{by_many $.Table}}{{by_index $.Table $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Executes the delete once for each provided key value and returns deleted rows.
-- name: BatchDelete{{by_many $.Table}}{{by_index $.Table $key}} :batchmany
DELETE FROM {{$.Table.Name}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}}
RETURNING *;

-- BatchExecDelete{{by_many $.Table}}{{by_index $.Table $key}} deletes multiple rows from '{{$.Table.Name}}'{{if $key.Name}} by {{$key.Name}}{{end}} in a single batch operation.
-- Executes the delete once for each provided key value and returns number of affected rows.
-- name: BatchExecDelete{{by_many $.Table}}{{by_index $.Table $key}} :batchexec
DELETE FROM {{$.Table.Name}}
{{- $where := where $.Table $key}}
{{- if $where}}
WHERE
    {{$where}}
{{- end}};

{{end}}
