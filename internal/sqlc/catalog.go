// Package sqlc provides data structures for working with sqlc catalog files.
//
// The catalog represents the database schema metadata generated by sqlc,
// including schemas, tables, columns, indexes, and foreign key relationships.
package sqlc

import (
	"cmp"
	"encoding/json"
	"fmt"
	"os"
	"slices"
	"strings"
)

// Catalog represents the root structure of a sqlc catalog file.
// It contains all schemas and their associated database objects.
type Catalog struct {
	Schemas []Schema `json:"schemas,omitempty"`
}

// LoadCatalog loads a sqlc catalog file from the specified path and returns a Catalog struct.
// The catalog file is expected to be in JSON format as generated by sqlc.
func LoadCatalog(path string) (*Catalog, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var catalog Catalog
	if err := json.Unmarshal(data, &catalog); err != nil {
		return nil, err
	}

	return &catalog, nil
}

// GetTable retrieves a table by name from the catalog.
// It searches through all schemas.
func (x *Catalog) GetTable(name string) *Table {
	for i := range x.Schemas {
		for j := range x.Schemas[i].Tables {
			if x.Schemas[i].Tables[j].Name == name {
				return &x.Schemas[i].Tables[j]
			}
		}
	}
	return nil
}

// Schema represents a database schema containing tables and other database objects.
type Schema struct {
	Name   string  `json:"name"`
	Tables []Table `json:"tables,omitempty"`
	// Inherit common attributes
	Attributes
}

// Table represents a database table with its columns, indexes, and constraints.
type Table struct {
	Name        string       `json:"name"`
	Columns     []Column     `json:"columns,omitempty"`
	Indexes     []Index      `json:"indexes,omitempty"`
	PrimaryKey  *Index       `json:"primary_key,omitempty"`
	ForeignKeys []ForeignKey `json:"foreign_keys,omitempty"`
	// Inherit common attributes
	Attributes
}

// GetColumn retrieves a column by name from the table.
func (x *Table) GetColumn(name string) *Column {
	for _, column := range x.Columns {
		if column.Name == name {
			return &column
		}
	}

	return nil
}

// GetNonUniqueIndexes retrieves all non-unique indexes from the table.
func (x *Table) GetNonUniqueIndexes() []*Index {
	var keys []*Index

	for _, index := range x.Indexes {
		if index.HasExpr() {
			continue
		}

		if !index.Unique {
			index.Name = cmp.Or(index.Name, "non-unique key")
			keys = append(keys, &index)
		}
	}

	return keys
}

// GetUniqueKeys retrieves all unique keys (primary key and unique indexes) from the table.
func (x *Table) GetUniqueKeys() []*Index {
	var keys []*Index

	if x.PrimaryKey != nil {
		x.PrimaryKey.Name = "primary key"
		keys = append(keys, x.PrimaryKey)
	}

	for _, index := range x.Indexes {
		if index.HasExpr() {
			continue
		}

		if index.Unique {
			index.Name = cmp.Or(index.Name, "unique key")
			keys = append(keys, &index)
		}
	}

	return keys
}

// GetNonPrimaryKeyColumns retrieves all columns from the table except the primary key columns.
// This is useful for generating UPDATE statements where primary keys should not be modified.
func (x *Table) GetNonPrimaryKeyColumns() []Column {
	var columns []Column

	// Get primary key column names for exclusion
	var pkColumns map[string]bool
	if x.PrimaryKey != nil {
		pkColumns = make(map[string]bool)
		for _, part := range x.PrimaryKey.Parts {
			pkColumns[part.Column] = true
		}
	}

	// Add all non-primary key columns
	for _, column := range x.Columns {
		if pkColumns == nil || !pkColumns[column.Name] {
			columns = append(columns, column)
		}
	}

	return columns
}

// Column represents a table column with its name, data type, and nullability.
type Column struct {
	Name string `json:"name"`
	Type string `json:"type,omitempty"`
	Null bool   `json:"null,omitempty"`
	// Inherit common attributes
	Attributes
}

// ColumnRef represents a reference to a specific column within a table.
type ColumnRef struct {
	Name  string
	Table *Table
}

// String returns the string representation of the ColumnRef for use in SQL queries.
func (x *ColumnRef) String() string {
	column := x.Table.GetColumn(x.Name)
	// Prepare the column reference in "table.column" format
	return fmt.Sprintf("%s.%s", x.Table.Name, column.Name)
}

// Index represents a database index on one or more columns or expressions.
type Index struct {
	Name   string      `json:"name,omitempty"`
	Unique bool        `json:"unique,omitempty"`
	Parts  []IndexPart `json:"parts,omitempty"`
}

// HasExpr checks if the index contains any expression-based parts.
func (x *Index) HasExpr() bool {
	return slices.ContainsFunc(x.Parts, func(x IndexPart) bool {
		return x.Expr != ""
	})
}

// IndexPart represents a single part of an index, which can be either a column or an expression.
type IndexPart struct {
	Desc   bool   `json:"desc,omitempty"`
	Column string `json:"column,omitempty"`
	Expr   string `json:"expr,omitempty"`
}

// ForeignKey represents a foreign key constraint linking columns in this table
// to columns in a referenced table.
type ForeignKey struct {
	Name       string   `json:"name"`
	Columns    []string `json:"columns,omitempty"`
	References struct {
		Table   string   `json:"table"`
		Columns []string `json:"columns,omitempty"`
	} `json:"references"`
}

// ArgumentCondition represents a simple equality condition between a column and an argument.
type ArgumentCondition struct {
	Column   *Column
	Argument *Argument
}

// String returns the string representation of the Condition for use in SQL queries.
func (x *ArgumentCondition) String() string {
	return fmt.Sprintf("%s = %v", x.Column.Name, x.Argument)
}

type ColumnCondition struct {
	Left  *ColumnRef
	Right *ColumnRef
}

// String returns the string representation of the Condition for use in SQL queries.
func (x *ColumnCondition) String() string {
	return fmt.Sprintf("%s = %s", x.Left.String(), x.Right.String())
}

// CompositeCondition represents a combination of multiple conditions using a logical operator (e.g., AND, OR).
type CompositeCondition struct {
	Operator   string
	Conditions []fmt.Stringer
}

// AddColumn adds a new condition for the specified column to the CompositeCondition.
func (x *CompositeCondition) AddColumn(column *Column) {
	x.Conditions = append(x.Conditions,
		&ArgumentCondition{
			Column: column,
			Argument: &Argument{
				Column: column,
			},
		},
	)
}

// AddColumnRef adds a new condition comparing two columns to the CompositeCondition.
func (x *CompositeCondition) AddColumnRef(left, right *ColumnRef) {
	x.Conditions = append(x.Conditions,
		&ColumnCondition{
			Left:  left,
			Right: right,
		},
	)
}

// String returns the string representation of the CompositeCondition for use in SQL queries.
func (x *CompositeCondition) String() string {
	var items []string

	for _, condition := range x.Conditions {
		if expression := condition.String(); expression != "" {
			items = append(items, expression)
		}
	}

	if len(items) == 0 {
		return ""
	}

	return strings.Join(items, fmt.Sprintf(" %s ", x.Operator))
}

// Argument represents SQL argument corresponding to a column.
type Argument struct {
	Column *Column
}

// String returns the string representation of the Argument for use in SQL queries.
func (x *Argument) String() string {
	// Prepare the argument string based on nullability
	if x.Column.Null {
		return fmt.Sprintf("sqlc.narg(%s)", x.Column.Name)
	}
	return fmt.Sprintf("sqlc.arg(%s)", x.Column.Name)
}

// Attributes represents common attributes that can be applied to schemas, tables, and columns.
// These are typically dialect-specific metadata.
type Attributes struct {
	Comment string `json:"comment,omitempty"`
	Charset string `json:"charset,omitempty"`
	Collate string `json:"collate,omitempty"`
}
